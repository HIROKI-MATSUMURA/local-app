// Node.jsモジュール読み込みエラー処理関数
function requireModule(moduleName) {
  try {
    // node:プレフィックスを試す（Node.js 14以降で推奨）
    try {
      return require(`node:${moduleName}`);
    } catch (e) {
      // 従来の方法でフォールバック
      console.log(`node:${moduleName}の読み込みに失敗、標準的な方法を試します`);
      return require(moduleName);
    }
  } catch (error) {
    console.error(`モジュール "${moduleName}" の読み込みに失敗しました:`, error);
    throw new Error(`モジュール "${moduleName}" が見つかりません: ${error.message}`);
  }
}

// 基本モジュールの読み込み
const electron = requireModule('electron');
const { app, BrowserWindow, ipcMain, dialog, session, shell } = electron;
const path = requireModule('path');
const fs = requireModule('fs');
const axios = requireModule('axios');
const { exec } = requireModule('child_process');
const { promisify } = requireModule('util');
const execAsync = promisify(exec);
const { v4: uuidv4 } = requireModule('uuid');
const url = requireModule('url');
const chokidar = requireModule('chokidar'); // Chokidarをインポート
const glob = requireModule('glob'); // Globをインポート
const { Configuration, OpenAIApi } = require('openai');
const fetch = require('node-fetch');

try {
  require('dotenv').config();
} catch (error) {
  console.warn('dotenvモジュールの読み込みに失敗しました。環境変数は.envから読み込まれません:', error);
}

// Pythonブリッジをロード
let pythonBridge, pythonAdapter;
try {
  pythonBridge = require('./python_bridge');
  pythonAdapter = require('./python_bridge_adapter');
} catch (error) {
  console.error('Pythonブリッジの読み込みに失敗しました:', error);
  pythonBridge = { checkPythonEnvironment: () => Promise.resolve({ success: false, error: 'モジュール読み込みエラー' }) };
  pythonAdapter = {};
}

// Electron設定のデバッグ情報
console.log('Electron設定情報:');
console.log('- isPackaged:', app.isPackaged);
console.log('- appPath:', app.getAppPath());
console.log('- 実行中のNode.jsバージョン:', process.versions.node);
console.log('- 実行中のElectronバージョン:', process.versions.electron);
console.log('- __dirname:', __dirname);
console.log('- preloadPath:', path.join(__dirname, 'preload.js'));
console.log('- preloadファイル存在確認:', fs.existsSync(path.join(__dirname, 'preload.js')));

// プロジェクト設定ファイルのパスを定義
const PROJECTS_CONFIG_PATH = path.join(app.getPath('userData'), 'projects.json');
const ACTIVE_PROJECT_PATH = path.join(app.getPath('userData'), 'active-project.json');
const CATEGORIES_PATH = path.join(app.getPath('userData'), 'categories.json');
const TAGS_PATH = path.join(app.getPath('userData'), 'tags.json');
const SELECTED_CATEGORY_PATH = path.join(app.getPath('userData'), 'selected-category.json');
const SELECTED_TAGS_PATH = path.join(app.getPath('userData'), 'selected-tags.json');

// 新しいファイルパスを追加（app.getName()を使用）
const appName = app.getName() || 'electron-app';
// Claude APIキー読み込み処理をここに追加
const apiKeyPath = path.join(__dirname, 'secret', 'api_key.json');
let CLAUDE_API_KEY = '';

try {
  const keyData = JSON.parse(fs.readFileSync(apiKeyPath, 'utf-8'));
  CLAUDE_API_KEY = keyData.claudeKey || '';
  console.log('[INFO] Claude APIキーを /secret/api_key.json から読み込みました');
} catch (e) {
  console.error('[ERROR] Claude APIキーの読み込みに失敗:', e);
}
// ハードコードされたAPIキー
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
const DEFAULT_PROVIDER = "claude"; // デフォルトはClaude

// グローバルエラーハンドリング
process.on('uncaughtException', (error) => {
  console.error('未捕捉の例外が発生しました:', error);
  // エラーログを保存するなどの追加処理も可能
});

// 開発環境かどうかを判定
const isDevelopment = process.env.NODE_ENV === 'development' || !app.isPackaged;

let mainWindow;

// グローバル変数としてスプラッシュウィンドウを宣言
let splashWindow;

// グローバル変数の宣言
let isElectronAppReloadBlocked = true; // Electronアプリでのリロードをブロックするフラグ
let isAICodeSaving = false; // AIコード保存中のフラグ

// promptGeneratorをインポート
try {
  promptGenerator = require('./promptGenerator');
  console.log('promptGeneratorを正常に読み込みました');
} catch (error) {
  console.error('promptGeneratorの読み込みに失敗しました:', error);
  promptGenerator = {
    generatePromptFromCompressedData: (data) => `デザイン解析データからプロンプトを生成できませんでした: ${error.message}`
  };
}

// 監視するディレクトリ
const htmlDirectory = path.join(__dirname, 'src');
// previousFilesをグローバルに宣言して、前回のファイルリストを保持
let previousFiles = [];

// JSONデータストア関連のパス設定
const PROJECT_DATA_DIR = path.join(app.getPath('userData'), 'projectData');

// アプリ起動時に監視を開始するフラグ
let isDirectoryWatcherInitialized = false;

// ファイル監視用のMap
const fileWatchers = new Map();

// プロジェクトファイル監視用のMap
const projectWatchers = new Map();
// プロジェクトの定期スキャンインターバル用のMap
const projectIntervals = new Map();

// HTMLファイルの作成を監視する
function watchDirectory() {
  if (!isDirectoryWatcherInitialized) {
    console.log('ディレクトリ監視を初期化します');
    isDirectoryWatcherInitialized = true;

    // 監視を1秒ごとにチェック - mainWindowが使用可能になるまで遅延
    const watchIntervalId = setInterval(() => {
      if (!mainWindow || mainWindow.isDestroyed()) {
        return; // mainWindowがまだ利用できない場合はスキップ
      }

      fs.readdir(htmlDirectory, (err, files) => {
        if (err) {
          console.error('Error reading directory:', err);
          return;
        }

        const htmlFiles = files.filter(file => file.endsWith('.html'));
        // 新しいファイルを検出
        const newFiles = htmlFiles.filter(file => !previousFiles.includes(file));

        // 新規ファイルのみを処理
        if (newFiles.length > 0) {
          newFiles.forEach(fileName => {
            console.log(`Detected new HTML file: ${fileName}`);
            // フロントエンドに新しいHTMLファイルを通知（mainWindowが存在する場合のみ）
            if (mainWindow && !mainWindow.isDestroyed()) {
              mainWindow.webContents.send('new-html-file', fileName);
            }
          });
        }

        // 今回のファイルリストを保存
        previousFiles = htmlFiles;
      });
    }, 1000); // 1秒ごとにチェック

    // アプリ終了時に監視を停止
    app.on('will-quit', () => {
      clearInterval(watchIntervalId);
    });
  }
}

// ファイル変更監視ハンドラー - Viteのリロードに頼らずElectronで独自に処理
function setupFileWatcher() {
  // HTMLファイルの変更を監視（グローバル監視）
  fs.watch(htmlDirectory, { recursive: true }, (eventType, filename) => {
    if (!filename) return;

    // HTMLファイルの変更のみを処理
    if (filename.endsWith('.html')) {
      console.log(`グローバルファイル変更を検出: ${filename} - イベント: ${eventType} - AIコード保存フラグ: ${isAICodeSaving}`);
      console.log(`ファイルパス: ${path.join(htmlDirectory, filename)}`);

      // AIコード保存中でない場合のみ通知を送信（保存中のリロードを防止）
      if (mainWindow && !mainWindow.isDestroyed() && !isAICodeSaving) {
        try {
          // ファイルタイプを判定
          const fileType = path.extname(filename).substring(1);

          // 安全なオブジェクトを作成
          const fileData = {
            type: fileType,
            fileType: fileType, // 明示的にfileTypeを追加
            eventType: eventType,
            fileName: filename,
            filename: filename,
            filePath: path.join(htmlDirectory, filename)
          };

          // シリアライズ可能なオブジェクトに変換
          const safeData = JSON.parse(JSON.stringify(fileData));

          mainWindow.webContents.send('file-changed', safeData);
          console.log('グローバル監視からファイル変更イベントを送信:', safeData);
        } catch (error) {
          console.error('ファイル変更通知の送信中にエラーが発生:', error);
        }
      } else if (isAICodeSaving) {
        console.log(`AIコード保存中のため、ファイル変更通知をスキップしました: ${filename}`);
      }
    }
  });

  console.log('グローバルファイル監視を設定しました');
}

// スプラッシュウィンドウを作成する関数
function createSplashWindow() {
  splashWindow = new BrowserWindow({
    width: 400,
    height: 300,
    transparent: true,
    frame: false,
    alwaysOnTop: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js'),
    }
  });

  splashWindow.loadFile(path.join(__dirname, 'src/electron/splash.html'));

  splashWindow.on('closed', () => {
    console.log('スプラッシュウィンドウが閉じられました');
    splashWindow = null;
  });
}

// メインウィンドウ作成関数
function createMainWindow() {
  console.log('メインウィンドウの作成を開始します');  // デバッグログ追加

  const windowWidth = 1280;
  const windowHeight = 800;

  // preloadスクリプトのパスを確認
  const preloadPath = path.join(__dirname, 'preload.js');
  console.log('preloadスクリプトのパス:', preloadPath);  // デバッグログ追加
  console.log('preloadスクリプトが存在するか:', fs.existsSync(preloadPath));  // デバッグログ追加

  // Python環境の初期化
  initializePythonEnvironment();
  const isDev = !app.isPackaged; // 開発モード判定

  // ウィンドウオプションを設定
  const windowOptions = {
    width: windowWidth,
    height: windowHeight,
    minWidth: 800,
    minHeight: 600,
    frame: true,
    show: false,
    title: 'CreAIte Code',
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      sandbox: false,
      preload: path.join(__dirname, 'preload.js'),
      webSecurity: !isDev, // 本番では true（開発では false）
      allowRunningInsecureContent: isDev, // 本番では false（開発では true）
      devTools: isDev,
    },
  };

  console.log('=== Electron起動ディレクトリ ===');
  console.log('__dirname:', __dirname);
  console.log('preload path:', path.join(__dirname, 'preload.js'));


  // メインウィンドウを作成
  mainWindow = new BrowserWindow(windowOptions);

  // メインウィンドウへの診断情報を設定
  mainWindow.ELECTRON_DISABLE_SECURITY_WARNINGS = false;

  // メインウィンドウのdevToolsを開く
  if (isDevelopment) {
    mainWindow.webContents.openDevTools();
  }

  // 環境変数情報をログ出力
  console.log('環境情報:', {
    isDevelopment: isDevelopment,
    appPath: app.getAppPath(),
    userData: app.getPath('userData'),
    isPackaged: app.isPackaged,
    resourcesPath: process.resourcesPath
  });

  // スプラッシュウィンドウが存在すれば閉じる関数
  const closeSplashWindow = () => {
    if (splashWindow && !splashWindow.isDestroyed()) {
      splashWindow.close();
    }
  };

  // CSP設定をセッションに直接適用
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': ["default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' https://fonts.googleapis.com 'unsafe-inline'; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:"]
      }
    });
  });

  // uploadsディレクトリを作成
  const uploadsDir = path.join(__dirname, "uploads");
  if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir, { recursive: true });
    console.log(`Created uploads directory at: ${uploadsDir}`);
  }

  console.log('NODE_ENV:', process.env.NODE_ENV);
  console.log('isDevelopment:', isDevelopment);

  // 開発環境と本番環境で適切なパスを使い分ける
  let filePath;

  if (isDevelopment) {
    // 開発環境では、Viteによってビルドされたファイルを使用
    filePath = path.join(__dirname, 'dist', 'index.html');
    console.log('開発モード: ビルド済みファイルを読み込みます:', filePath);
  } else {
    // 本番環境では、パッケージ化されたファイルを使用
    filePath = path.join(__dirname, 'dist', 'index.html');
    console.log('本番モード: ビルド済みファイルを読み込みます:', filePath);
  }

  // ブラウザコンソールのログを表示
  mainWindow.webContents.on('console-message', (event, level, message, line, sourceId) => {
    console.log(`[WebContents] ${message}`);
  });

  // ファイルを読み込む
  mainWindow.loadFile(filePath).catch(err => {
    console.error('ファイル読み込みエラー:', err);

    // 読み込み失敗時のフォールバック
    const fallbackPath = path.join(__dirname, 'src', 'electron', 'index.html');
    console.log('フォールバックファイルを読み込みます:', fallbackPath);
    mainWindow.loadFile(fallbackPath).catch(fallbackErr => {
      console.error('フォールバックファイルの読み込みにも失敗:', fallbackErr);
    });
  });

  // レンダリングの問題をデバッグするためのフラグを設定
  app.commandLine.appendSwitch('disable-site-isolation-trials');

  // ウィンドウが閉じられたときにメインウィンドウを破棄
  mainWindow.on('closed', () => {
    console.log('メインウィンドウが閉じられました');
    mainWindow = null;
  });

  // メインウィンドウの準備ができたら表示
  mainWindow.once('ready-to-show', () => {
    console.log('メインウィンドウの表示準備完了');

    // スプラッシュウィンドウが存在すれば閉じる
    if (splashWindow && !splashWindow.isDestroyed()) {
      console.log('スプラッシュウィンドウを閉じます');
      splashWindow.close();
      splashWindow = null;
    }

    // 0.5秒待ってからメインウィンドウを表示（スプラッシュが完全に閉じるのを待つ）
    setTimeout(() => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.show();
      }
    }, 500);
  });

  // ファイル監視対象
  const watchFiles = [
    path.join(__dirname, 'src/scss/base/_reset.scss'),
    path.join(__dirname, 'src/scss/global/_breakpoints.scss'),
  ];

  // ファイルの監視処理
  watchFiles.forEach((file) => {
    fs.watchFile(file, (curr, prev) => {
      fs.readFile(file, 'utf8', (err, data) => {
        if (!err && mainWindow) {
          mainWindow.webContents.send('file-updated', { file, content: data });
        }
      });
    });
  });

  // ウィンドウの読み込みイベントをリッスン
  mainWindow.webContents.on('did-start-loading', () => {
    console.log('ウィンドウの読み込みを開始しました');  // デバッグログ追加
  });

  mainWindow.webContents.on('did-finish-load', () => {
    console.log('ウィンドウの読み込みが完了しました');  // デバッグログ追加
  });

  mainWindow.webContents.on('dom-ready', () => {
    console.log('DOMの準備が完了しました');  // デバッグログ追加
  });

  return mainWindow;
}

// Python環境を初期化する関数
async function initializePythonEnvironment() {
  try {
    console.log('Python環境の初期化を開始します...');

    // Pythonが利用可能かチェック
    const pythonVersion = await checkPythonVersion();
    console.log(`Python ${pythonVersion} が検出されました`);

    // Python環境を初期化
    const initResult = await pythonAdapter.initializePythonBridge();
    if (initResult) {
      console.log('Python環境の初期化に成功しました');

      // Pythonブリッジを起動
      await pythonBridge.start();
      console.log('Pythonブリッジが正常に起動しました');

      // 環境チェック
      const checkResult = await pythonBridge.checkPythonEnvironment();
      console.log('Python環境チェック結果:', checkResult);

      if (checkResult.status !== 'ok') {
        console.log('Python環境のセットアップを実行します...');
        console.log('必要なPythonパッケージをインストールしています...');

        const setupResult = await pythonBridge.setupPythonEnvironment();
        console.log('Python環境セットアップ結果:', setupResult);

        if (setupResult.success) {
          // セットアップ成功後に再起動
          await pythonBridge.restart();
          console.log('Pythonブリッジを再起動しました');
        }
      }

      return true;
    } else {
      console.error('Python環境の初期化に失敗しました');
      return false;
    }
  } catch (error) {
    console.error('Python環境初期化エラー:', error);
    return false;
  }
}

// Pythonバージョンを確認する関数
async function checkPythonVersion() {
  try {
    const { exec } = require('child_process');
    const { promisify } = require('util');
    const execAsync = promisify(exec);

    const pythonCmd = process.platform === 'win32' ? 'python --version' : 'python3 --version';
    const { stdout } = await execAsync(pythonCmd);

    const versionMatch = stdout.match(/Python\s+(\d+\.\d+\.\d+)/i);
    if (versionMatch && versionMatch[1]) {
      return versionMatch[1];
    } else {
      return '不明なバージョン';
    }
  } catch (error) {
    console.error('Pythonバージョン確認エラー:', error);
    return '確認失敗';
  }
}

// アプリケーションが起動したら
app.whenReady().then(async () => {
  // Python環境のセットアップを実行
  await initializePythonEnvironment();

  // スプラッシュウィンドウを作成
  createSplashWindow();

  // ユーザーデータディレクトリとパスを確認
  const userDataPath = app.getPath('userData');
  console.log('ユーザーデータディレクトリ:', userDataPath);
  console.log('設定ファイルパス:');
  console.log(`- PROJECTS_CONFIG_PATH: ${PROJECTS_CONFIG_PATH}`);
  console.log(`- ACTIVE_PROJECT_PATH: ${ACTIVE_PROJECT_PATH}`);
  console.log(`- CATEGORIES_PATH: ${CATEGORIES_PATH}`);
  console.log(`- TAGS_PATH: ${TAGS_PATH}`);
  console.log(`- SELECTED_CATEGORY_PATH: ${SELECTED_CATEGORY_PATH}`);
  console.log(`- SELECTED_TAGS_PATH: ${SELECTED_TAGS_PATH}`);

  // CSPの設定
  session.defaultSession.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; style-src 'self' https://fonts.googleapis.com 'unsafe-inline'; font-src 'self' https://fonts.gstatic.com"
        ]
      }
    });
  });

  // 重要: カテゴリとタグの初期化を他の処理より先に実行
  try {
    console.log('カテゴリとタグの初期化を開始します...');

    // userData ディレクトリの確認
    if (!fs.existsSync(userDataPath)) {
      fs.mkdirSync(userDataPath, { recursive: true });
      console.log(`userData ディレクトリを作成しました: ${userDataPath}`);
    }

    // ファイル存在確認と初期化（存在しない場合のみ）
    const defaultCategories = ['uncategorized', '制作会社', 'コミュニティ', 'エンド'];
    if (!fs.existsSync(CATEGORIES_PATH)) {
      fs.writeFileSync(CATEGORIES_PATH, JSON.stringify(defaultCategories), 'utf8');
      console.log('カテゴリファイルを作成しました:', defaultCategories);
    } else {
      // ファイルは存在するが、uncategorizedが含まれているか確認
      try {
        const currentCategories = JSON.parse(fs.readFileSync(CATEGORIES_PATH, 'utf8'));
        if (Array.isArray(currentCategories) && !currentCategories.includes('uncategorized')) {
          // uncategorizedが含まれていない場合は追加
          const updatedCategories = ['uncategorized', ...currentCategories];
          fs.writeFileSync(CATEGORIES_PATH, JSON.stringify(updatedCategories), 'utf8');
          console.log('既存のカテゴリにuncategorizedを追加しました:', updatedCategories);
        } else {
          console.log('カテゴリファイルは既に存在し、適切な内容のため初期化をスキップします');
        }
      } catch (err) {
        console.error('カテゴリファイルの検証中にエラーが発生しました:', err);
        console.log('カテゴリファイルは既に存在するため、初期化をスキップします');
      }
    }

    // タグファイル
    const defaultTags = ['A社', 'B社'];
    if (!fs.existsSync(TAGS_PATH)) {
      fs.writeFileSync(TAGS_PATH, JSON.stringify(defaultTags), 'utf8');
      console.log('タグファイルを作成しました:', defaultTags);
    } else {
      console.log('タグファイルは既に存在するため、初期化をスキップします');
    }

    // 選択中カテゴリファイル
    if (!fs.existsSync(SELECTED_CATEGORY_PATH)) {
      fs.writeFileSync(SELECTED_CATEGORY_PATH, JSON.stringify('all'), 'utf8');
      console.log('選択中カテゴリファイルを作成しました: all');
    } else {
      console.log('選択中カテゴリファイルは既に存在するため、初期化をスキップします');
    }

    // 選択中タグファイル
    if (!fs.existsSync(SELECTED_TAGS_PATH)) {
      fs.writeFileSync(SELECTED_TAGS_PATH, JSON.stringify([]), 'utf8');
      console.log('選択中タグファイルを作成しました: []');
    } else {
      console.log('選択中タグファイルは既に存在するため、初期化をスキップします');
    }

    // 読み込みテスト - 確実に作成されたか確認
    console.log('ファイル作成確認:');
    console.log('- カテゴリファイル存在:', fs.existsSync(CATEGORIES_PATH));
    console.log('- タグファイル存在:', fs.existsSync(TAGS_PATH));
    console.log('- 選択カテゴリファイル存在:', fs.existsSync(SELECTED_CATEGORY_PATH));
    console.log('- 選択タグファイル存在:', fs.existsSync(SELECTED_TAGS_PATH));

    // ファイル内容確認
    try {
      const catContent = fs.readFileSync(CATEGORIES_PATH, 'utf8');
      console.log('カテゴリファイル内容:', catContent);
    } catch (err) {
      console.error('カテゴリファイル読み込みエラー:', err);
    }

    console.log('カテゴリとタグの初期化が完了しました');
  } catch (error) {
    console.error('カテゴリとタグの初期化中にエラーが発生しました:', error);
  }

  console.log('アプリ起動時にIPCハンドラーを設定します');
  setupIPCHandlers();
  setupFileWatcher();

  // 出力ディレクトリの準備
  const outputPath = path.join(__dirname, 'output');
  try {
    if (!fs.existsSync(outputPath)) {
      fs.mkdirSync(outputPath, { recursive: true });
      console.log('出力ディレクトリを作成しました:', outputPath);
    }
  } catch (err) {
    console.error('出力ディレクトリの作成に失敗しました:', err);
  }

  // メインウィンドウの作成をわずかに遅延させる
  setTimeout(() => {
    createMainWindow();

    // ディレクトリ監視を開始
    watchDirectory();
  }, 1000);

  // Mac OS の場合、アプリがアクティブ化されたらメインウィンドウを作成
  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createMainWindow();
    }
  });

  // コンソール情報を取得する関数
  function getConsoleInfo() {
    try {
      const consoleInfo = {
        nodeVersion: process.version,
        electronVersion: process.versions.electron,
        chromeVersion: process.versions.chrome,
        platform: process.platform,
        arch: process.arch,
        memoryUsage: process.memoryUsage(),
        uptime: process.uptime()
      };
      return consoleInfo;
    } catch (error) {
      console.error('コンソール情報の取得に失敗:', error);
      return null;
    }
  }

  // コンソール情報を定期的に取得する関数
  function startConsoleMonitoring() {
    setInterval(() => {
      const consoleInfo = getConsoleInfo();
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('console-info-updated', consoleInfo);
      }
    }, 5000); // 5秒ごとに更新
  }

  // コンソール監視を開始
  startConsoleMonitoring();
});

// Macでアプリケーションが閉じられる際の処理
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

// デフォルト設定ファイルのパスを定義
const DEFAULT_SETTINGS_PATH = path.join(app.getPath('userData'), 'default-settings.json');

// デフォルト設定の読み込み
function loadDefaultSettings() {
  try {
    if (fs.existsSync(DEFAULT_SETTINGS_PATH)) {
      const data = fs.readFileSync(DEFAULT_SETTINGS_PATH, 'utf8');
      return JSON.parse(data);
    }
    return null;
  } catch (error) {
    console.error('デフォルト設定の読み込みに失敗:', error);
    return null;
  }
}

// デフォルト設定の保存
function saveDefaultSettings(settings) {
  try {
    fs.writeFileSync(DEFAULT_SETTINGS_PATH, JSON.stringify(settings, null, 2));
    return true;
  } catch (error) {
    console.error('デフォルト設定の保存に失敗:', error);
    return false;
  }
}

function watchProjectFiles(projectId, projectPath, patterns = ['**/*.html', '**/*.css', '**/*.scss', '**/*.js', '**/*.json']) {
  try {
    // 既存のウォッチャーがあれば閉じる
    unwatchProjectFiles(projectId);

    console.log(`プロジェクト[${projectId}]のファイル監視を開始: ${projectPath}`);
    console.log('監視パターン:', patterns);

    // ウォッチするHTMLファイルのパターンを追加
    const htmlPatterns = [
      'src/pages/**/*.html',
      'src/html/**/*.html',
      ...(patterns.filter(p => p.includes('.html')))
    ];

    // 除外パターン（partsHTMLディレクトリを除外）
    const ignoredPatterns = [
      '**/node_modules/**',
      '**/dist/**',
      '**/build/**',
      '**/partsHTML/**', // partsHTMLディレクトリを明示的に除外
      '**/*.json', // JSONファイルを監視対象から除外（自動生成されるため）
    ];

    // 監視済みファイルを追跡するためのSet
    const watchedFiles = new Set();

    // chokidarの設定
    const watcher = chokidar.watch(patterns, {
      cwd: projectPath,
      ignored: [
        /(^|[\/\\])\../, // ドットファイルを無視
        ...ignoredPatterns
      ],
      persistent: true,
      ignoreInitial: false,
      awaitWriteFinish: {
        stabilityThreshold: 500,
        pollInterval: 100
      }
    });

    // インターバルIDを保存するための配列を初期化
    if (!projectIntervals.has(projectId)) {
      projectIntervals.set(projectId, []);
    }

    // イベントハンドラー
    watcher
      .on('add', async path => {
        // partsHTMLディレクトリ内のファイルは無視
        if (path.includes('partsHTML/')) {
          console.log(`partsHTMLディレクトリのファイルはスキップ: ${path}`);
          return;
        }

        // ファイルが既に処理済みかチェック
        const fullPath = `${projectPath}/${path}`;
        if (watchedFiles.has(fullPath)) {
          console.log(`既に処理済みのファイル: ${path}`);
          return;
        }

        watchedFiles.add(fullPath);
        console.log(`ファイル追加検知: ${path}`);

        // HTMLファイルの場合、対応するJSONファイルを更新（オプション）
        if (path.endsWith('.html')) {
          try {
            // HTMLファイルの内容を読み込む
            const htmlContent = fs.readFileSync(`${projectPath}/${path}`, 'utf8');

            // ファイル内容をJSONに同期
            try {
              await syncFileToJson(projectId, `${projectPath}/${path}`, 'html');
            } catch (error) {
              console.error(`ファイル同期エラー (${path}):`, error);
            }
          } catch (error) {
            console.error(`HTMLファイル処理エラー: ${path}`, error);
          }
        } else {
          // 他のファイルタイプを処理
          const fileType = path.split('.').pop();

          // ファイル内容をJSONに同期
          try {
            await syncFileToJson(projectId, `${projectPath}/${path}`, fileType);
          } catch (error) {
            console.error(`ファイル同期エラー (${path}):`, error);
          }
        }

        // フロントエンドに通知
        if (mainWindow) {
          const fileType = path.split('.').pop();
          const eventData = {
            type: 'add',
            projectId: projectId,
            eventType: 'add',
            path: path,
            filePath: `${projectPath}/${path}`,
            fileType: fileType,
            fileName: path.split('/').pop(),
            timestamp: new Date().toISOString()
          };

          mainWindow.webContents.send('file-event', eventData);
          mainWindow.webContents.send('file-changed', eventData);
          console.log('ファイル追加イベントを送信:', eventData);
        }
      })
      .on('change', async path => {
        // partsHTMLディレクトリ内のファイルは無視
        if (path.includes('partsHTML/')) {
          return;
        }

        console.log(`ファイル変更検知: ${path}`);

        // HTMLファイルの場合の処理
        if (path.endsWith('.html')) {
          try {
            // ファイル内容をJSONに同期
            await syncFileToJson(projectId, `${projectPath}/${path}`, 'html');
          } catch (error) {
            console.error(`ファイル同期エラー (${path}):`, error);
          }
        } else {
          // 他のファイルタイプを処理
          const fileType = path.split('.').pop();

          // ファイル内容をJSONに同期
          try {
            await syncFileToJson(projectId, `${projectPath}/${path}`, fileType);
          } catch (error) {
            console.error(`ファイル同期エラー (${path}):`, error);
          }
        }

        // フロントエンドに通知
        if (mainWindow) {
          const fileType = path.split('.').pop();
          const eventData = {
            type: 'change',
            projectId: projectId,
            eventType: 'change',
            path: path,
            filePath: `${projectPath}/${path}`,
            fileType: fileType,
            fileName: path.split('/').pop(),
            timestamp: new Date().toISOString()
          };

          mainWindow.webContents.send('file-event', eventData);
          mainWindow.webContents.send('file-changed', eventData);
          console.log('ファイル変更イベントを送信:', eventData);
        }
      })
      .on('unlink', async path => {
        // partsHTMLディレクトリ内のファイルは無視
        if (path.includes('partsHTML/')) {
          return;
        }

        // Setから削除
        const fullPath = `${projectPath}/${path}`;
        watchedFiles.delete(fullPath);

        console.log(`ファイル削除検知: ${path}`);

        // ファイルタイプを判定
        const fileType = path.split('.').pop();

        // フロントエンドに通知
        if (mainWindow) {
          const eventData = {
            type: 'unlink',
            projectId: projectId,
            eventType: 'unlink',
            path: path,
            filePath: `${projectPath}/${path}`,
            fileType: fileType,
            fileName: path.split('/').pop(),
            timestamp: new Date().toISOString()
          };

          // ログ出力を追加
          console.log('ファイル削除イベントを送信:', JSON.stringify(eventData));

          // イベント名を両方試す
          mainWindow.webContents.send('file-event', eventData);
          mainWindow.webContents.send('file-changed', eventData);

          // 1秒後に再度送信して確実に届くようにする
          setTimeout(() => {
            console.log('ファイル削除イベントを再送信:', JSON.stringify(eventData));
            mainWindow.webContents.send('file-changed', eventData);
          }, 1000);
        }
      })
      .on('error', error => {
        console.error(`ファイル監視エラー: ${error}`);
      });

    // ウォッチャーを保存
    projectWatchers.set(projectId, watcher);

    // 初回スキャン後に手動で再スキャン（1回のみ）
    const initialScanTimeout = setTimeout(() => {
      console.log(`プロジェクト[${projectId}] 初期スキャン後の確認スキャンを実行`);
      try {
        // HTMLファイルを再確認（一度だけ）
        htmlPatterns.forEach(pattern => {
          // partsHTMLディレクトリを除外
          if (pattern.includes('partsHTML')) return;

          const htmlFiles = glob.sync(pattern, {
            cwd: projectPath,
            ignore: ignoredPatterns
          });

          console.log(`パターン[${pattern}]で検出されたHTMLファイル:`, htmlFiles);

          htmlFiles.forEach(async htmlPath => {
            // partsHTMLディレクトリのファイルは無視
            if (htmlPath.includes('partsHTML/')) {
              console.log(`partsHTMLディレクトリのファイルはスキップ: ${htmlPath}`);
              return;
            }

            const fullPath = `${projectPath}/${htmlPath}`;
            if (!watchedFiles.has(fullPath)) {
              console.log(`確認スキャンで検出された未処理ファイル: ${htmlPath}`);

              try {
                // ファイル内容をJSONに同期
                await syncFileToJson(projectId, fullPath, 'html');

                // フロントエンドに通知
                if (mainWindow) {
                  const eventData = {
                    type: 'add',
                    projectId: projectId,
                    eventType: 'add',
                    path: htmlPath,
                    filePath: fullPath,
                    fileType: 'html',
                    fileName: htmlPath.split('/').pop(),
                    timestamp: new Date().toISOString()
                  };

                  mainWindow.webContents.send('file-event', eventData);
                  mainWindow.webContents.send('file-changed', eventData);
                  console.log('ファイル検出イベントを送信:', eventData);
                }

                watchedFiles.add(fullPath);
              } catch (error) {
                console.error(`HTMLファイル処理エラー: ${htmlPath}`, error);
              }
            }
          });
        });
      } catch (error) {
        console.error('確認スキャンエラー:', error);
      }
    }, 5000);

    // タイマーを保存
    projectIntervals.get(projectId).push(initialScanTimeout);

    // 30秒ごとにファイルシステムを再スキャン（新規ファイル検出用）
    const scanInterval = setInterval(() => {
      console.log(`プロジェクト[${projectId}] 定期再スキャンを実行`);
      try {
        // HTMLファイルを再スキャン
        htmlPatterns.forEach(pattern => {
          // partsHTMLディレクトリを除外
          if (pattern.includes('partsHTML')) return;

          const htmlFiles = glob.sync(pattern, {
            cwd: projectPath,
            ignore: ignoredPatterns
          });

          htmlFiles.forEach(async htmlPath => {
            // partsHTMLディレクトリのファイルは無視
            if (htmlPath.includes('partsHTML/')) return;

            const fullPath = `${projectPath}/${htmlPath}`;
            if (!watchedFiles.has(fullPath)) {
              // 未処理のHTMLファイルがあれば処理
              console.log(`定期スキャンで検出された新規ファイル: ${htmlPath}`);

              try {
                // ファイル内容をJSONに同期
                await syncFileToJson(projectId, fullPath, 'html');

                // フロントエンドに通知
                if (mainWindow) {
                  const eventData = {
                    type: 'add',
                    projectId: projectId,
                    eventType: 'add',
                    path: htmlPath,
                    filePath: fullPath,
                    fileType: 'html',
                    fileName: htmlPath.split('/').pop(),
                    timestamp: new Date().toISOString()
                  };

                  mainWindow.webContents.send('file-event', eventData);
                  mainWindow.webContents.send('file-changed', eventData);
                  console.log('ファイル検出イベントを送信:', eventData);
                }

                watchedFiles.add(fullPath);
              } catch (error) {
                console.error(`HTMLファイル処理エラー: ${htmlPath}`, error);
              }
            }
          });
        });
      } catch (error) {
        console.error('定期再スキャンエラー:', error);
      }
    }, 30000);

    // インターバルIDを保存
    projectIntervals.get(projectId).push(scanInterval);

    return true;
  } catch (error) {
    console.error('ファイル監視の設定中にエラーが発生しました:', error);
    return false;
  }
}

// ファイル監視の停止
function unwatchProjectFiles(projectId) {
  try {
    console.log(`プロジェクト[${projectId}]のファイル監視を停止します`);
    if (projectWatchers.has(projectId)) {
      // ウォッチャーを閉じる
      projectWatchers.get(projectId).close();
      projectWatchers.delete(projectId);
      console.log(`プロジェクト[${projectId}]のファイル監視を停止しました`);

      // 定期スキャンインターバルもクリア
      if (projectIntervals.has(projectId)) {
        const intervals = projectIntervals.get(projectId);
        intervals.forEach(intervalId => {
          clearInterval(intervalId);
          console.log(`プロジェクト[${projectId}]の定期スキャンを停止しました`);
        });
        projectIntervals.delete(projectId);
      }

      return true;
    } else {
      console.log(`プロジェクト[${projectId}]の監視は既に停止しています`);
      return false;
    }
  } catch (error) {
    console.error('ファイル監視の停止中にエラーが発生しました:', error);
    return false;
  }
}

// アクティブプロジェクトIDの保存
async function saveActiveProjectId(projectId) {
  try {
    await fs.promises.writeFile(ACTIVE_PROJECT_PATH, JSON.stringify({ activeProjectId: projectId }));
    console.log('アクティブプロジェクトIDを保存しました:', projectId);
    return true;
  } catch (error) {
    console.error('アクティブプロジェクトIDの保存に失敗:', error);
    return false;
  }
}

// アクティブプロジェクトIDの読み込み
async function loadActiveProjectId() {
  try {
    if (fs.existsSync(ACTIVE_PROJECT_PATH)) {
      const data = await fs.promises.readFile(ACTIVE_PROJECT_PATH, 'utf8');
      const { activeProjectId } = JSON.parse(data);
      console.log('アクティブプロジェクトIDを読み込みました:', activeProjectId);
      return activeProjectId;
    }
    return null;
  } catch (error) {
    console.error('アクティブプロジェクトIDの読み込みに失敗:', error);
    return null;
  }
}

// カテゴリの読み込み
async function loadCategories() {
  try {
    if (fs.existsSync(CATEGORIES_PATH)) {
      const data = await fs.promises.readFile(CATEGORIES_PATH, 'utf8');
      return JSON.parse(data);
    }
    return null;
  } catch (error) {
    console.error('カテゴリの読み込みに失敗:', error);
    return null;
  }
}

// カテゴリの保存
async function saveCategories(categories) {
  try {
    // ディレクトリが存在することを確認
    const dirPath = path.dirname(CATEGORIES_PATH);
    if (!fs.existsSync(dirPath)) {
      await fs.promises.mkdir(dirPath, { recursive: true });
    }

    await fs.promises.writeFile(CATEGORIES_PATH, JSON.stringify(categories));
    console.log(`カテゴリを保存しました: ${CATEGORIES_PATH}`, categories);
    return true;
  } catch (error) {
    console.error('カテゴリの保存に失敗:', error);
    return false;
  }
}

// タグの読み込み
async function loadTags() {
  try {
    if (fs.existsSync(TAGS_PATH)) {
      const data = await fs.promises.readFile(TAGS_PATH, 'utf8');
      return JSON.parse(data);
    }
    return null;
  } catch (error) {
    console.error('タグの読み込みに失敗:', error);
    return null;
  }
}

// タグの保存
async function saveTags(tags) {
  try {
    // ディレクトリが存在することを確認
    const dirPath = path.dirname(TAGS_PATH);
    if (!fs.existsSync(dirPath)) {
      await fs.promises.mkdir(dirPath, { recursive: true });
    }

    await fs.promises.writeFile(TAGS_PATH, JSON.stringify(tags));
    console.log(`タグを保存しました: ${TAGS_PATH}`, tags);
    return true;
  } catch (error) {
    console.error('タグの保存に失敗:', error);
    return false;
  }
}

// 選択中のカテゴリを保存するパス

// 選択中のカテゴリを保存
async function saveSelectedCategory(category) {
  try {
    // ディレクトリが存在することを確認
    const dirPath = path.dirname(SELECTED_CATEGORY_PATH);
    if (!fs.existsSync(dirPath)) {
      await fs.promises.mkdir(dirPath, { recursive: true });
    }

    await fs.promises.writeFile(SELECTED_CATEGORY_PATH, JSON.stringify(category));
    console.log(`選択中のカテゴリを保存しました: ${SELECTED_CATEGORY_PATH}`, category);
    return true;
  } catch (error) {
    console.error('選択中のカテゴリの保存に失敗:', error);
    return false;
  }
}

// 選択中のカテゴリを読み込み
async function loadSelectedCategory() {
  try {
    if (fs.existsSync(SELECTED_CATEGORY_PATH)) {
      const data = await fs.promises.readFile(SELECTED_CATEGORY_PATH, 'utf8');
      return JSON.parse(data);
    }
    return null;
  } catch (error) {
    console.error('選択中のカテゴリの読み込みに失敗:', error);
    return null;
  }
}

// 選択中のタグを保存するパス

// 選択中のタグを保存
async function saveSelectedTags(tags) {
  try {
    // ディレクトリが存在することを確認
    const dirPath = path.dirname(SELECTED_TAGS_PATH);
    if (!fs.existsSync(dirPath)) {
      await fs.promises.mkdir(dirPath, { recursive: true });
    }

    await fs.promises.writeFile(SELECTED_TAGS_PATH, JSON.stringify(tags));
    console.log(`選択中のタグを保存しました: ${SELECTED_TAGS_PATH}`, tags);
    return true;
  } catch (error) {
    console.error('選択中のタグの保存に失敗:', error);
    return false;
  }
}

// 選択中のタグを読み込み
async function loadSelectedTags() {
  try {
    if (fs.existsSync(SELECTED_TAGS_PATH)) {
      const data = await fs.promises.readFile(SELECTED_TAGS_PATH, 'utf8');
      return JSON.parse(data);
    }
    return null;
  } catch (error) {
    console.error('選択中のタグの読み込みに失敗:', error);
    return null;
  }
}

// IPC ハンドラーを設定する関数
function setupIPCHandlers() {
  // 必要なディレクトリの作成
  const ensureDirectories = () => {
    const directories = [
      path.join(__dirname, 'src'),
      path.join(__dirname, 'src/scss'),
      path.join(__dirname, 'src/scss/object'),
      path.join(__dirname, 'src/scss/object/AI_Component'),
      path.join(__dirname, 'src/partsHTML')
    ];

    directories.forEach(dir => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
        console.log(`ディレクトリを作成しました: ${dir}`);
      }
    });

    // プロジェクトデータディレクトリも確保
    try {
      if (!fs.existsSync(PROJECT_DATA_DIR)) {
        fs.mkdirSync(PROJECT_DATA_DIR, { recursive: true });
      }
    } catch (error) {
      console.error('プロジェクトデータディレクトリの作成に失敗しました:', error);
    }
  };

  // カテゴリー関連のハンドラー
  ipcMain.handle('loadCategories', async () => {
    try {
      const categories = await loadCategories();
      return categories;
    } catch (error) {
      console.error('カテゴリ読み込みエラー:', error);
      throw error;
    }
  });

  ipcMain.handle('saveCategories', async (event, categories) => {
    try {
      await saveCategories(categories);
      return { success: true };
    } catch (error) {
      console.error('カテゴリ保存エラー:', error);
      throw error;
    }
  });

  // タグ関連のハンドラー
  ipcMain.handle('loadTags', async () => {
    try {
      const tags = await loadTags();
      return tags;
    } catch (error) {
      console.error('タグ読み込みエラー:', error);
      throw error;
    }
  });

  ipcMain.handle('saveTags', async (event, tags) => {
    try {
      await saveTags(tags);
      return { success: true };
    } catch (error) {
      console.error('タグ保存エラー:', error);
      throw error;
    }
  });

  // 設定関連のハンドラー
  ipcMain.handle('loadDefaultSettings', async () => {
    try {
      return loadDefaultSettings();
    } catch (error) {
      console.error('デフォルト設定読み込みエラー:', error);
      throw error;
    }
  });

  // プロジェクト関連のハンドラー
  ipcMain.handle('load-active-project-id', async () => {
    try {
      return await loadActiveProjectId();
    } catch (error) {
      console.error('アクティブプロジェクトID読み込みエラー:', error);
      throw error;
    }
  });

  ipcMain.handle('load-projects-config', async () => {
    try {
      if (fs.existsSync(PROJECTS_CONFIG_PATH)) {
        const data = await fs.promises.readFile(PROJECTS_CONFIG_PATH, 'utf8');
        return JSON.parse(data);
      }
      return {};
    } catch (error) {
      console.error('プロジェクト設定読み込みエラー:', error);
      throw error;
    }
  });

  // プロジェクトファイル監視ハンドラー
  ipcMain.handle('watch-project-files', async (event, { projectId, projectPath, patterns }) => {
    try {
      console.log(`プロジェクトファイル監視リクエスト: ${projectId} - ${projectPath}`);
      // パターンが正しく配列であることを確認
      const watchPatterns = Array.isArray(patterns) ? patterns : ['**/*.html', '**/*.css', '**/*.scss', '**/*.js', '**/*.json'];

      // watchProjectFiles関数を呼び出してファイル監視を開始
      const result = watchProjectFiles(projectId, projectPath, watchPatterns);
      return { success: result };
    } catch (error) {
      console.error('プロジェクトファイル監視エラー:', error);
      return { success: false, error: error.message };
    }
  });

  // プロジェクトファイル監視停止ハンドラー
  ipcMain.handle('unwatch-project-files', async (event, projectId) => {
    try {
      console.log(`プロジェクトファイル監視停止リクエスト: ${projectId}`);
      const result = unwatchProjectFiles(projectId);
      return { success: result };
    } catch (error) {
      console.error('プロジェクトファイル監視停止エラー:', error);
      return { success: false, error: error.message };
    }
  });

  // プロジェクト設定の保存
  ipcMain.handle('save-project-settings', async (event, project) => {
    try {
      // 既存のプロジェクト設定を読み込む
      let projects = {};
      if (fs.existsSync(PROJECTS_CONFIG_PATH)) {
        const data = await fs.promises.readFile(PROJECTS_CONFIG_PATH, 'utf8');
        projects = JSON.parse(data);
      }

      // 新しいプロジェクト設定を追加または更新
      projects[project.id] = project;

      // プロジェクト設定を保存
      await fs.promises.writeFile(PROJECTS_CONFIG_PATH, JSON.stringify(projects, null, 2));
      console.log(`プロジェクト設定を保存しました: ${project.id}`);
      return { success: true };
    } catch (error) {
      console.error('プロジェクト設定保存エラー:', error);
      return { success: false, error: error.message };
    }
  });

  // プロジェクト設定の読み込み
  ipcMain.handle('load-project-settings', async (event, projectId) => {
    try {
      if (fs.existsSync(PROJECTS_CONFIG_PATH)) {
        const data = await fs.promises.readFile(PROJECTS_CONFIG_PATH, 'utf8');
        const projects = JSON.parse(data);
        return projects[projectId] || null;
      }
      return null;
    } catch (error) {
      console.error('プロジェクト設定読み込みエラー:', error);
      return null;
    }
  });

  // プロジェクト設定の削除
  ipcMain.handle('delete-project-settings', async (event, projectId) => {
    try {
      if (fs.existsSync(PROJECTS_CONFIG_PATH)) {
        const data = await fs.promises.readFile(PROJECTS_CONFIG_PATH, 'utf8');
        const projects = JSON.parse(data);

        if (projects[projectId]) {
          delete projects[projectId];
          await fs.promises.writeFile(PROJECTS_CONFIG_PATH, JSON.stringify(projects, null, 2));
          console.log(`プロジェクト設定を削除しました: ${projectId}`);
        }
      }
      return { success: true };
    } catch (error) {
      console.error('プロジェクト設定削除エラー:', error);
      return { success: false, error: error.message };
    }
  });

  // プロジェクトデータの保存/読み込みハンドラー
  ipcMain.handle('save-project-data', async (event, { projectId, section, data }) => {
    try {
      const result = await saveProjectData(projectId, section, data);
      return { success: result };
    } catch (error) {
      console.error('プロジェクトデータ保存エラー:', error);
      return { success: false, error: error.message };
    }
  });

  ipcMain.handle('load-project-data', async (event, { projectId, section }) => {
    try {
      const data = await loadProjectData(projectId, section);
      return data;
    } catch (error) {
      console.error('プロジェクトデータ読み込みエラー:', error);
      return null;
    }
  });

  // Python画像処理ハンドラー
  ipcMain.handle('extract-text-from-image', async (event, imageData) => {
    try {
      console.log('画像からテキスト抽出リクエストを受信');
      // pythonブリッジを通じて画像からテキストを抽出
      if (!pythonBridge) {
        console.error('Pythonブリッジが初期化されていません');
        return { success: false, error: 'Pythonブリッジが初期化されていません' };
      }
      const result = await pythonBridge.extractTextFromImage(imageData);
      console.log('画像からテキスト抽出が完了しました');
      return result;
    } catch (error) {
      console.error('画像からテキスト抽出エラー:', error);
      return { success: false, error: error.message || String(error) };
    }
  });

  ipcMain.handle('extract-colors-from-image', async (event, imageData) => {
    try {
      console.log('画像から色抽出リクエストを受信');
      // pythonブリッジを通じて画像から色を抽出
      if (!pythonBridge) {
        console.error('Pythonブリッジが初期化されていません');
        console.error('Pythonパッケージインストールエラー:', error);
        return {
          success: false,
          error: error.message
        };
      }
    });
}

// ファイル内容をJSONデータに同期
async function syncFileToJson(projectId, filePath, fileType) {
  try {
    // サポートするファイルタイプとJSONのセクション名のマッピング
    const fileTypeToSection = {
      'html': 'htmlContents',
      'css': 'cssContents',
      'scss': 'scssContents',
      'js': 'jsContents',
      'json': 'jsonContents',
      'md': 'mdContents',
      'txt': 'txtContents'
    };

    // ファイルタイプからセクションを判定
    const section = fileTypeToSection[fileType];
    if (!section) {
      console.log(`未対応のファイルタイプ: ${fileType}`);
      return false; // 未対応のファイルタイプ
    }

    // ファイル内容を読み込む
    const content = await fs.promises.readFile(filePath, 'utf8');
    const fileName = path.basename(filePath);
    console.log(`ファイル内容をJSONに同期します: ${fileName} (${fileType} -> ${section})`);

    // 現在のデータを読み込む
    const currentData = await loadProjectData(projectId, section) || {};

    // ファイルデータを更新
    currentData[fileName] = content;

    // 更新したデータを保存
    await saveProjectData(projectId, section, currentData);
    console.log(`ファイル内容をJSONに同期しました: ${fileName} (${section})`);

    // HTML/SCSSファイルの場合は追加でファイルリストも更新
    if (fileType === 'html' || fileType === 'scss') {
      const listSection = fileType === 'html' ? 'htmlFiles' : 'scssFiles';
      const listData = await loadProjectData(projectId, listSection) || [];
      console.log(`ファイルリストを更新します: ${fileName} (${listSection})`);

      // 既にリストにあるかチェック
      if (!listData.some(file => file.name === fileName)) {
        // 新規ファイルの場合は追加
        listData.push({
          id: uuidv4(),
          name: fileName,
          status: '保存済',
          lastModified: new Date().toISOString()
        });

        // リストを保存
        await saveProjectData(projectId, listSection, listData);
        console.log(`ファイルリストを更新しました: ${fileName} (${listSection})`);
      } else {
        console.log(`ファイルは既にリストに存在します: ${fileName} (${listSection})`);
      }
    }

    return true;
  } catch (error) {
    console.error('ファイル同期に失敗:', error);
    return false;
  }
}

// プロジェクトデータの保存
async function saveProjectData(projectId, section, data) {
  try {
    if (!projectId) {
      console.error('プロジェクトIDが指定されていません');
      return false;
    }

    // JSONデータの保存先ディレクトリを確保
    const projectDir = path.join(PROJECT_DATA_DIR, projectId);
    await fs.promises.mkdir(projectDir, { recursive: true });

    // セクション別のJSONファイルパス
    const filePath = path.join(projectDir, `${section}.json`);

    // データと最終更新日時を保存
    const jsonData = {
      data,
      lastModified: new Date().toISOString()
    };

    // JSONファイルに保存
    await fs.promises.writeFile(filePath, JSON.stringify(jsonData, null, 2), 'utf8');
    console.log(`プロジェクトデータを保存しました: ${projectId}/${section}`);
    return true;
  } catch (error) {
    console.error(`プロジェクトデータの保存エラー (${projectId}/${section}):`, error);
    return false;
  }
}

// プロジェクトデータの読み込み
async function loadProjectData(projectId, section) {
  try {
    if (!projectId) {
      console.error('プロジェクトIDが指定されていません');
      return null;
    }

    // セクション別のJSONファイルパス
    const filePath = path.join(PROJECT_DATA_DIR, projectId, `${section}.json`);

    // ファイルが存在するか確認
    if (!fs.existsSync(filePath)) {
      console.log(`プロジェクトデータが見つかりません: ${projectId}/${section}`);
      return null;
    }

    // JSONファイルから読み込み
    const fileData = await fs.promises.readFile(filePath, 'utf8');
    const jsonData = JSON.parse(fileData);
    console.log(`プロジェクトデータを読み込みました: ${projectId}/${section}`);

    // データ部分のみを返す
    return jsonData.data;
  } catch (error) {
    console.error(`プロジェクトデータの読み込みエラー (${projectId}/${section}):`, error);
    return null;
  }
}
