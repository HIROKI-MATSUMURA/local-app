#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# GPU使用の完全無効化
import os
os.environ["CUDA_VISIBLE_DEVICES"] = "-1"
os.environ["TF_FORCE_CPU_ONLY"] = "1"

# PyTorchスレッド数の制限
import torch
torch.set_num_threads(1)

# プロセス生成方式の明示的指定
import multiprocessing
multiprocessing.set_start_method('spawn', force=True)

"""
Python Server for Image Analysis
ElectronアプリケーションのJavaScriptからリクエストを受け取り、
image_analyzer.pyにある画像処理機能を呼び出して結果を返します。
"""

import sys
import os
import json
import uuid
import base64
import traceback
import logging
from datetime import datetime
from typing import Dict, Any, Optional, List, Tuple
import importlib.util
import time
import threading
import cv2
import argparse
import requests  # APIリクエスト用
import hashlib
import numpy as np
from contextlib import redirect_stdout, redirect_stderr
import io
import gc

# エラー出力をUTF-8でログファイルに保存（最優先）
stderr_log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'logs')
os.makedirs(stderr_log_dir, exist_ok=True)
stderr_log_path = os.path.join(stderr_log_dir, f'stderr_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')
sys.stderr = open(stderr_log_path, "w", encoding="utf-8", errors="replace", buffering=1)
# 確認用メッセージを出力し、即座にフラッシュする
print(f"標準エラー出力をログファイルにリダイレクトしました: {stderr_log_path}", file=sys.stderr, flush=True)
print(f"Python実行環境: {sys.executable}", file=sys.stderr, flush=True)
print(f"カレントディレクトリ: {os.getcwd()}", file=sys.stderr, flush=True)
print(f"システムエンコーディング: {sys.getdefaultencoding()}", file=sys.stderr, flush=True)

# NonClosingStringIOクラスを追加
class NonClosingStringIO(io.StringIO):
    def close(self):
        # closeメソッドをオーバーライドして何もしないようにする
        pass

# Windows環境での文字化けとUnicodeエラーを防ぐためにUTF-8を強制設定
# より強力なエンコーディング設定（errors='backslashreplace'を追加）
if os.name == 'nt':  # Windows環境の場合
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(encoding='utf-8', errors='backslashreplace')
        sys.stderr.reconfigure(encoding='utf-8', errors='backslashreplace')
    else:
        # Python 3.7未満の環境用
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', 
                                     errors='backslashreplace', line_buffering=True)
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', 
                                     errors='backslashreplace', line_buffering=True)
    
    # Windowsの警告抑制
    import warnings
    warnings.filterwarnings("ignore", category=UnicodeWarning)
else:
    # Mac/Linux環境用の設定
    if hasattr(sys.stdout, 'reconfigure'):
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    else:
        # Python 3.7未満の環境用
        if sys.stdout.encoding != 'utf-8':
            sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
        if sys.stderr.encoding != 'utf-8':
            sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# ロギング設定
# ログディレクトリを作成
log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'logs')
os.makedirs(log_dir, exist_ok=True)

# 現在時刻でログファイル名を作成
log_file = os.path.join(log_dir, f'python_server_{datetime.now().strftime("%Y%m%d_%H%M%S")}.log')

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file, encoding='utf-8'),  # UTF-8でログファイルを作成
        logging.StreamHandler(sys.stderr)  # 標準エラー出力にログを出力
    ]
)

# ロガー作成
logger = logging.getLogger('python_server')
logger.info(f"ログファイルを作成しました: {log_file}")

# グローバル変数
image_analyzer = None  # 画像解析モジュールのインスタンス

# 実行ディレクトリをスクリプトのある場所に変更
script_dir = os.path.dirname(os.path.abspath(__file__))
os.chdir(script_dir)

def initialize_image_analyzer():
    """画像解析モジュールを初期化する"""
    global image_analyzer

    try:
        # 画像解析モジュールのパスを特定
        script_dir = os.path.dirname(os.path.abspath(__file__))
        analyzer_path = os.path.join(script_dir, 'modules', 'image_analyzer.py')

        logger.info(f"画像解析モジュールのパス: {analyzer_path}")

        # パスが見つからない場合の代替パスを試す（パッケージ化されたアプリケーション用）
        if not os.path.exists(analyzer_path):
            logger.warning(f"標準パスで画像解析モジュールが見つかりません。代替パスを試行します。")
            # 親ディレクトリのmodulesディレクトリを試す
            parent_dir = os.path.dirname(script_dir)
            analyzer_path = os.path.join(parent_dir, 'modules', 'image_analyzer.py')
            logger.info(f"代替パス: {analyzer_path}")

            # それでも見つからない場合は、extraResourcesの相対パスを試す
            if not os.path.exists(analyzer_path):
                logger.warning(f"代替パスでも見つかりません。リソースパスを試行します。")
                analyzer_path = os.path.join(script_dir, '..', 'modules', 'image_analyzer.py')
                analyzer_path = os.path.abspath(analyzer_path)
                logger.info(f"リソースパス: {analyzer_path}")

        if not os.path.exists(analyzer_path):
            logger.error(f"image_analyzer.py が見つかりません: {analyzer_path}")
            return False

        # モジュールを動的にインポート
        spec = importlib.util.spec_from_file_location("image_analyzer", analyzer_path)
        image_analyzer_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(image_analyzer_module)

        # モジュールをグローバル変数に設定
        image_analyzer = image_analyzer_module

        logger.info("image_analyzer モジュールが正常に初期化されました")
        return True

    except Exception as e:
        logger.error(f"画像解析モジュールの初期化中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        return False

def read_request() -> Optional[Dict[str, Any]]:
    """標準入力からJSONリクエストを読み取る"""
    try:
        line = sys.stdin.readline()
        if not line:
            return None

        return json.loads(line)

    except json.JSONDecodeError as e:
        logger.error(f"JSONデコードエラー: {str(e)}")
        return None

    except Exception as e:
        logger.error(f"リクエスト読み取り中にエラーが発生しました: {str(e)}")
        return None

def send_response(request_id: str, result: Any = None, error: str = None):
    """JSONレスポンスを標準出力に送信する"""
    try:
        logger.info(f"===== send_response 詳細ステップログ開始 ID:{request_id} =====")
        print(f"[PYTHON_DEBUG] send_response 詳細ステップログ開始: ID={request_id}", file=sys.stderr, flush=True)
        
        # ステップ1: レスポンス構造体の構築
        logger.info("ステップ1: レスポンス構造体の構築")
        print("[PYTHON_DEBUG] ステップ1: レスポンス構造体の構築", file=sys.stderr, flush=True)
        
        response = {
            "id": request_id,
            "result": result,
            "error": error
        }
        logger.info("ステップ1完了: レスポンス構造体の構築完了")
        print("[PYTHON_DEBUG] ステップ1完了: レスポンス構造体の構築完了", file=sys.stderr, flush=True)
        
        # ステップ2: データ内容の検証とログ記録
        logger.info("ステップ2: データ内容の検証")
        print("[PYTHON_DEBUG] ステップ2: データ内容の検証", file=sys.stderr, flush=True)
        
        if result is not None:
            if isinstance(result, dict):
                logger.info(f"Python→JS送信データ構造: キー={list(result.keys())}")
                print(f"[PYTHON_DEBUG] 送信データ構造: キー={list(result.keys())}", file=sys.stderr, flush=True)
                
                # 大きなレスポンスの詳細情報
                if len(json.dumps(result)) > 10240:  # 10KB以上
                    logger.info(f"大きなレスポンス: {len(json.dumps(result))}バイト")
                    print(f"[PYTHON_DEBUG] 大きなレスポンス: {len(json.dumps(result))}バイト", file=sys.stderr, flush=True)
            else:
                logger.info(f"Python→JS送信データ型: {type(result).__name__}")
        logger.info("ステップ2完了: データ内容の検証完了")
        print("[PYTHON_DEBUG] ステップ2完了: データ内容の検証完了", file=sys.stderr, flush=True)
        
        # ステップ3: JSON形式に変換
        logger.info("ステップ3: JSON形式に変換")
        print("[PYTHON_DEBUG] ステップ3: JSON形式に変換", file=sys.stderr, flush=True)
        
        output = json.dumps(response, ensure_ascii=False)
        logger.info(f"ステップ3完了: JSONエンコード後のサイズ: {len(output)}バイト")
        print(f"[PYTHON_DEBUG] ステップ3完了: JSONエンコード後のサイズ: {len(output)}バイト", file=sys.stderr, flush=True)
        
        # ステップ4: 環境に応じた送信処理
        logger.info("ステップ4: 環境に応じた送信処理")
        print("[PYTHON_DEBUG] ステップ4: 環境に応じた送信処理", file=sys.stderr, flush=True)
        
        # Windows環境では特別な処理を追加
        if os.name == 'nt':
            try:
                # ステップ4.1: Windows向け特別処理の準備
                logger.info("ステップ4.1: Windowsモードでの送信準備")
                print(f"[PYTHON_DEBUG] ステップ4.1: Windowsモードでの送信準備", file=sys.stderr, flush=True)
                
                # 標準出力をバイナリモードで開き直す
                logger.info("ステップ4.2: 標準出力のバイナリモード設定開始")
                print(f"[PYTHON_DEBUG] ステップ4.2: 標準出力のバイナリモード設定開始", file=sys.stderr, flush=True)
                
                import msvcrt
                msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
                
                logger.info("ステップ4.2完了: 標準出力のバイナリモード設定完了")
                print(f"[PYTHON_DEBUG] ステップ4.2完了: 標準出力のバイナリモード設定完了", file=sys.stderr, flush=True)
                
                # ステップ4.3: UTF-8エンコード
                logger.info("ステップ4.3: UTF-8エンコード開始")
                print("[PYTHON_DEBUG] ステップ4.3: UTF-8エンコード開始", file=sys.stderr, flush=True)
                
                data_bytes = (output + '__END__').encode('utf-8')
                
                logger.info(f"ステップ4.3完了: エンコード後のバイト数: {len(data_bytes)}")
                print(f"[PYTHON_DEBUG] ステップ4.3完了: エンコード後のバイト数: {len(data_bytes)}", file=sys.stderr, flush=True)
                
                # ステップ4.4: バイナリデータ書き込み前の安全対策
                logger.info("ステップ4.4: バイナリデータ書き込み直前の安全対策")
                print(f"[PYTHON_DEBUG] ステップ4.4: バイナリデータ書き込み直前の安全対策", file=sys.stderr, flush=True)
                
                # ガベージコレクションを強制実行して潜在的なメモリ問題を回避
                gc.collect()
                
                # ステップ4.5: データ書き込み
                logger.info("ステップ4.5: sys.stdout.buffer.write()実行開始")
                print("[PYTHON_DEBUG] ステップ4.5: sys.stdout.buffer.write()実行開始", file=sys.stderr, flush=True)
                
                # 実際のバイト書き込み - ここでクラッシュする可能性が最も高い
                try:
                    sys.stdout.buffer.write(data_bytes)
                    logger.info("ステップ4.5完了: sys.stdout.buffer.write()実行完了")
                    print("[PYTHON_DEBUG] ステップ4.5完了: sys.stdout.buffer.write()実行完了", file=sys.stderr, flush=True)
                except Exception as write_error:
                    logger.error(f"ステップ4.5エラー: バッファ書き込み失敗: {str(write_error)}")
                    print(f"[PYTHON_DEBUG] ステップ4.5エラー: バッファ書き込み失敗: {str(write_error)}", file=sys.stderr, flush=True)
                    raise  # 再スロー
                
                # ステップ4.6: フラッシュ実行
                logger.info("ステップ4.6: sys.stdout.buffer.flush()実行開始")
                print("[PYTHON_DEBUG] ステップ4.6: sys.stdout.buffer.flush()実行開始", file=sys.stderr, flush=True)
                
                try:
                    sys.stdout.buffer.flush()
                    logger.info("ステップ4.6完了: sys.stdout.buffer.flush()実行完了")
                    print("[PYTHON_DEBUG] ステップ4.6完了: sys.stdout.buffer.flush()実行完了", file=sys.stderr, flush=True)
                except Exception as flush_error:
                    logger.error(f"ステップ4.6エラー: バッファフラッシュ失敗: {str(flush_error)}")
                    print(f"[PYTHON_DEBUG] ステップ4.6エラー: バッファフラッシュ失敗: {str(flush_error)}", file=sys.stderr, flush=True)
                    raise  # 再スロー
                
                # 送信完了ログ
                logger.info(f"ステップ4完了: Windows環境での送信完了: {len(data_bytes)}バイト")
                print(f"[PYTHON_DEBUG] ステップ4完了: Windows環境での送信完了: {len(data_bytes)}バイト", file=sys.stderr, flush=True)
            except Exception as windows_error:
                # Windows特有のエラーをキャッチ
                logger.error(f"Windows環境での送信エラー: {str(windows_error)}", exc_info=True)
                print(f"[PYTHON_DEBUG] Windows環境での送信エラー: {str(windows_error)}", file=sys.stderr, flush=True)
                
                # 通常モードでフォールバック
                logger.info("フォールバック: 通常モードでの送信試行")
                print("[PYTHON_DEBUG] フォールバック: 通常モードでの送信試行", file=sys.stderr, flush=True)
                print(output + '__END__', flush=True)
                logger.info("フォールバック: 通常モードでの送信完了")
                print("[PYTHON_DEBUG] フォールバック: 通常モードでの送信完了", file=sys.stderr, flush=True)
        else:
            # 非Windows環境では通常の処理
            logger.info("ステップ4.1: 非Windows環境での通常送信")
            print("[PYTHON_DEBUG] ステップ4.1: 非Windows環境での通常送信", file=sys.stderr, flush=True)
            print(output + '__END__', flush=True)
            logger.info("ステップ4.1完了: 非Windows環境での送信完了")
            print("[PYTHON_DEBUG] ステップ4.1完了: 非Windows環境での送信完了", file=sys.stderr, flush=True)
            
        # 送信完了ログ
        logger.info(f"===== send_response 詳細ステップログ完了 ID:{request_id} =====")
        print(f"[PYTHON_DEBUG] send_response 詳細ステップログ完了: ID={request_id}", file=sys.stderr, flush=True)
    except Exception as e:
        # 例外発生時の詳細ログ
        logger.error(f"send_response エラー: {str(e)}", exc_info=True)
        print(f"[PYTHON_DEBUG] send_response エラー: {str(e)}", file=sys.stderr, flush=True)
        traceback.print_exc(file=sys.stderr)
        
        # フォールバック送信を試行
        try:
            logger.info("クリティカルエラー後のフォールバック送信試行")
            print("[PYTHON_DEBUG] クリティカルエラー後のフォールバック送信試行", file=sys.stderr, flush=True)
            fallback_response = {
                "id": request_id,
                "error": f"応答送信中にエラーが発生: {str(e)}"
            }
            print(json.dumps(fallback_response, ensure_ascii=False) + '__END__', flush=True)
            logger.info("クリティカルエラー後のフォールバック送信完了")
            print("[PYTHON_DEBUG] クリティカルエラー後のフォールバック送信完了", file=sys.stderr, flush=True)
        except Exception as fallback_error:
            # 絶対に失敗しない最後の手段
            logger.critical(f"フォールバック送信も失敗: {str(fallback_error)}")
            print(f"[PYTHON_DEBUG] フォールバック送信も失敗: {str(fallback_error)}", file=sys.stderr, flush=True)
            print(f'{{"id":"{request_id}","error":"Critical error occurred"}}__END__', flush=True)

# オプションをクリーンアップする関数を追加
def clean_options(options: Dict[str, Any]) -> Dict[str, Any]:
    """オプション辞書をクリーンアップして安全に使えるようにする"""
    if not options or not isinstance(options, dict):
        return {}
    
    # 安全なオプションを作成
    clean_opts = options.copy()
    
    # 'image'キーがある場合は削除（競合防止）
    if 'image' in clean_opts:
        del clean_opts['image']
    
    # その他の危険な値や無効な値を削除/変換
    for key in list(clean_opts.keys()):
        # Noneや空オブジェクトを削除
        if clean_opts[key] is None:
            del clean_opts[key]
        # 不正な形式の値を修正
        elif key == 'language' and not isinstance(clean_opts[key], str):
            clean_opts[key] = str(clean_opts[key])
    
    return clean_opts

def handle_exit(request_id: str, params: Dict[str, Any]):
    """サーバーを終了する"""
    try:
        result = {
            "status": "ok",
            "message": "Pythonサーバーを終了します",
            "timestamp": datetime.now().isoformat()
        }
        
        send_response(request_id, result)
        
        # 終了メッセージをログに記録
        logger.info("exitコマンドを受信しました。サーバーを終了します。")
        
    except Exception as e:
        logger.error(f"終了処理中にエラーが発生しました: {str(e)}")
        send_response(request_id, None, f"終了処理エラー: {str(e)}")

def handle_check_memory(request_id: str, params: Dict[str, Any]):
    """メモリ使用状況を確認する"""
    try:
        import psutil
        import platform
        
        # 現在のプロセスのメモリ使用状況を取得
        process = psutil.Process(os.getpid())
        memory_info = process.memory_info()
        
        # システム全体のメモリ情報
        system_memory = psutil.virtual_memory()
        
        result = {
            "status": "ok",
            "process_memory": {
                "rss": memory_info.rss,  # 物理メモリ使用量 (バイト)
                "rss_mb": round(memory_info.rss / (1024 * 1024), 2),  # MB単位
                "vms": memory_info.vms,  # 仮想メモリ使用量 (バイト)
                "vms_mb": round(memory_info.vms / (1024 * 1024), 2),  # MB単位
            },
            "system_memory": {
                "total": system_memory.total,  # 合計物理メモリ (バイト)
                "total_gb": round(system_memory.total / (1024**3), 2),  # GB単位
                "available": system_memory.available,  # 利用可能な物理メモリ (バイト)
                "available_gb": round(system_memory.available / (1024**3), 2),  # GB単位
                "used_percent": system_memory.percent,  # 使用率 (%)
            },
            "platform": platform.platform(),
            "python_version": sys.version,
            "timestamp": datetime.now().isoformat()
        }
        
        # GPU情報の取得を試みる
        try:
            if torch.cuda.is_available():
                result["gpu"] = {
                    "device_count": torch.cuda.device_count(),
                    "current_device": torch.cuda.current_device(),
                    "device_name": torch.cuda.get_device_name(0),
                    "is_available": True
                }
            else:
                result["gpu"] = {
                    "is_available": False,
                    "reason": "CUDA not available"
                }
        except Exception as gpu_error:
            result["gpu"] = {
                "is_available": False,
                "error": str(gpu_error)
            }
        
        # ガベージコレクションの実行
        gc_count = gc.collect()
        result["gc_collected"] = gc_count
        
        send_response(request_id, result)
        
    except Exception as e:
        logger.error(f"メモリ確認中にエラーが発生しました: {str(e)}")
        error_info = {
            "status": "error",
            "error": str(e),
            "traceback": traceback.format_exc()
        }
        send_response(request_id, error_info)

def handle_compare_images(request_id: str, params: Dict[str, Any]):
    """2つの画像を比較する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data1 = params.get('image_data1', '')
        image_data2 = params.get('image_data2', '')
        options = params.get('options', {})

        if not image_data1 or not image_data2:
            raise ValueError("比較する2つの画像データが必要です")

        # Base64データを画像に変換
        image1, _ = base64_to_image_data(image_data1)
        image2, _ = base64_to_image_data(image_data2)

        # オプションのimageを除外して衝突回避
        clean_opts = clean_options(options)

        # 画像比較処理を実行
        # この関数はimage_analyzer.pyに実装されている必要があります
        comparison_result = image_analyzer.compare_images(image1, image2, **clean_opts)

        send_response(request_id, comparison_result)

    except Exception as e:
        logger.error(f"画像比較中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"画像比較エラー: {str(e)}")

def handle_extract_text(request_id: str, params: Dict[str, Any]):
    """画像からテキストを抽出する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        logger.info(f"テキスト抽出リクエスト受信: {request_id}")

        # パラメータを取得
        image_data = None
        # 複数の可能なキー名をチェック
        for key in ['image_data', 'imageData', 'image']:
            if key in params and params[key]:
                image_data = params[key]
                logger.info(f"受信パラメータのキー: {list(params.keys())}")
                logger.info(f"画像データ形式: {type(image_data).__name__}")
                logger.info(f"画像データサイズ: {len(image_data) if isinstance(image_data, str) else 'N/A'}")
                logger.info(f"画像データプレビュー: {image_data[:50]}..." if isinstance(image_data, str) and len(image_data) > 50 else 'N/A')
                break

        options = params.get('options', {})

        if not image_data:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data)

        # OCR実行前に明示的にPyTorchスレッド数を再設定
        try:
            import torch
            torch.set_num_threads(1)
            logger.info(f"OCR実行前にPyTorchスレッド数を制限: {torch.get_num_threads()}スレッド")
            print(f"[PYTHON_DEBUG] OCR実行前にPyTorchスレッド数を制限: {torch.get_num_threads()}スレッド", file=sys.stderr, flush=True)
            
            # GPUの無効化を明示的に再確認
            if 'CUDA_VISIBLE_DEVICES' in os.environ:
                logger.info(f"GPU無効化設定を確認: CUDA_VISIBLE_DEVICES={os.environ['CUDA_VISIBLE_DEVICES']}")
                print(f"[PYTHON_DEBUG] GPU無効化設定を確認: CUDA_VISIBLE_DEVICES={os.environ['CUDA_VISIBLE_DEVICES']}", file=sys.stderr, flush=True)
        except Exception as thread_err:
            logger.warning(f"PyTorchスレッド設定エラー: {str(thread_err)}")
            print(f"[PYTHON_DEBUG] PyTorchスレッド設定エラー: {str(thread_err)}", file=sys.stderr, flush=True)
        
        # ガベージコレクションをOCR実行前に実行
        try:
            import gc
            gc.collect()
            logger.info("OCR実行前にガベージコレクションを実行")
            print("[PYTHON_DEBUG] OCR実行前にガベージコレクションを実行", file=sys.stderr, flush=True)
        except Exception as gc_err:
            logger.warning(f"ガベージコレクション実行エラー: {str(gc_err)}")
            print(f"[PYTHON_DEBUG] ガベージコレクション実行エラー: {str(gc_err)}", file=sys.stderr, flush=True)

        # 標準出力をキャプチャするためのバッファを作成
        output_buffer = NonClosingStringIO()
        
        logger.info("テキスト抽出処理開始")
        print("[PYTHON_DEBUG] テキスト抽出処理開始", file=sys.stderr, flush=True)
        
        try:
            # 出力をキャプチャしながらOCR実行
            with redirect_stdout(output_buffer), redirect_stderr(output_buffer):
                # verbose=False で進捗バーを無効化
                text_options = clean_options(options).copy()
                text_options['verbose'] = False
                
                logger.info("extract_text_from_image関数の呼び出し直前")
                print("[PYTHON_DEBUG] extract_text_from_image関数の呼び出し直前", file=sys.stderr, flush=True)
                
                # OCR実行
                text_result = image_analyzer.extract_text_from_image(image=image, **text_options)
                
                logger.info("extract_text_from_image関数の呼び出し完了")
                print("[PYTHON_DEBUG] extract_text_from_image関数の呼び出し完了", file=sys.stderr, flush=True)
                
                # withブロック内でバッファ内容を取得する（重要）
                try:
                    captured_output = output_buffer.getvalue()
                    if captured_output:
                        logger.debug(f"キャプチャした出力（先頭300文字）: {captured_output[:300]}...")
                except Exception as buffer_err:
                    logger.error(f"バッファ読み取りエラー: {buffer_err}")
        except Exception as redirect_err:
            logger.error(f"出力リダイレクトエラー: {redirect_err}", exc_info=True)
            print(f"[PYTHON_DEBUG] 出力リダイレクトエラー: {redirect_err}", file=sys.stderr, flush=True)
            # リダイレクトなしで処理を続行
            text_options = clean_options(options).copy()
            text_options['verbose'] = False
            
            logger.info("リダイレクトなしでのOCR処理再試行")
            print("[PYTHON_DEBUG] リダイレクトなしでのOCR処理再試行", file=sys.stderr, flush=True)
            text_result = image_analyzer.extract_text_from_image(image=image, **text_options)
            logger.info("リダイレクトなしでのOCR処理完了")
            print("[PYTHON_DEBUG] リダイレクトなしでのOCR処理完了", file=sys.stderr, flush=True)
        
        # OCR結果のデータ構造を検証
        logger.info(f"OCR結果タイプ: {type(text_result).__name__}")
        print(f"[PYTHON_DEBUG] OCR結果タイプ: {type(text_result).__name__}", file=sys.stderr, flush=True)
        
        if isinstance(text_result, dict):
            logger.info(f"OCR結果構造: キー={list(text_result.keys())}")
            print(f"[PYTHON_DEBUG] OCR結果構造: キー={list(text_result.keys())}", file=sys.stderr, flush=True)
        
        logger.info("テキスト抽出完了")
        print("[PYTHON_DEBUG] テキスト抽出完了", file=sys.stderr, flush=True)
        
        send_response(request_id, text_result)

    except Exception as e:
        logger.error(f"テキスト抽出中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"テキスト抽出エラー: {str(e)}")

def handle_analyze_all(request_id, image_path, options=None):
    """ 画像からテキストと色を抽出して結果を返す """
    
    if options is None:
        options = {}
    
    try:
        logging.info(f"Windows環境: analyze_all関数の実行開始 {request_id}")
        
        # OCRでテキスト抽出
        text_data = handle_extract_text(None, image_path, options)
        logging.info(f"OCR完了: {len(text_data)} 文字抽出")
        
        # 色抽出
        colors_options = clean_options(options.get('colors', {}))
        extracted_colors = handle_extract_colors(None, image_path, colors_options)
        logging.info(f"色抽出完了: {len(extracted_colors)} 色")
        
        # 結果を作成
        result = {
            'text': text_data,
            'colors': extracted_colors
        }
        
        # 重要: レスポンスの送信をtryブロック内で行う
        send_response(request_id, 'analyze_all', result)
        logging.info(f"analyze_all完了: レスポンス送信済み")
        
    except Exception as e:
        error_msg = f"analyze_all内で例外発生: {str(e)}"
        logging.exception(error_msg)
        send_error(request_id, 'analyze_all', error_msg)
def analyze_all(image, options):
            result = {
                'success': True,
                'status': 'ok',
                'text': '',
                'textBlocks': [],
                'colors': [],
                'timestamp': datetime.now().isoformat()
            }
            
            logger.info(f"総合分析の実行 - オプション: {options}")
            print(f"総合分析の実行 - オプション: {options}", file=sys.stderr, flush=True)
            
            try:
                # 出力キャプチャバッファを作成
                output_buffer = NonClosingStringIO()
                
                # テキスト抽出
                if not options.get('skip_text', False):
                    try:
                        logger.info("テキスト抽出処理開始")
                        print("テキスト抽出処理開始", file=sys.stderr, flush=True)
                        
                        # OCR実行前に明示的にPyTorchスレッド数を再設定
                        try:
                            import torch
                            torch.set_num_threads(1)
                            logger.info(f"OCR実行前にPyTorchスレッド数を制限: {torch.get_num_threads()}スレッド")
                            print(f"[PYTHON_DEBUG] OCR実行前にPyTorchスレッド数を制限: {torch.get_num_threads()}スレッド", file=sys.stderr, flush=True)
                            
                            # GPUの無効化を明示的に再確認
                            if 'CUDA_VISIBLE_DEVICES' in os.environ:
                                logger.info(f"GPU無効化設定を確認: CUDA_VISIBLE_DEVICES={os.environ['CUDA_VISIBLE_DEVICES']}")
                                print(f"[PYTHON_DEBUG] GPU無効化設定を確認: CUDA_VISIBLE_DEVICES={os.environ['CUDA_VISIBLE_DEVICES']}", file=sys.stderr, flush=True)
                        except Exception as thread_err:
                            logger.warning(f"PyTorchスレッド設定エラー: {str(thread_err)}")
                            print(f"[PYTHON_DEBUG] PyTorchスレッド設定エラー: {str(thread_err)}", file=sys.stderr, flush=True)
                        
                        # ガベージコレクションをOCR実行前に実行
                        try:
                            import gc
                            gc.collect()
                            logger.info("OCR実行前にガベージコレクションを実行")
                            print("[PYTHON_DEBUG] OCR実行前にガベージコレクションを実行", file=sys.stderr, flush=True)
                        except Exception as gc_err:
                            logger.warning(f"ガベージコレクション実行エラー: {str(gc_err)}")
                            print(f"[PYTHON_DEBUG] ガベージコレクション実行エラー: {str(gc_err)}", file=sys.stderr, flush=True)
                        
                        try:
                            # 出力をキャプチャしながらOCR実行
                            with redirect_stdout(output_buffer), redirect_stderr(output_buffer):
                                # verbose=False で進捗バーを無効化
                                text_options = clean_options(options).copy()
                                text_options['verbose'] = False
                                
                                logger.info("extract_text_from_image関数の呼び出し直前")
                                print("[PYTHON_DEBUG] extract_text_from_image関数の呼び出し直前", file=sys.stderr, flush=True)
                                
                                # OCR実行
                                text_result = image_analyzer.extract_text_from_image(image=image, **text_options)
                                
                                logger.info("extract_text_from_image関数の呼び出し完了")
                                print("[PYTHON_DEBUG] extract_text_from_image関数の呼び出し完了", file=sys.stderr, flush=True)
                                
                                # withブロック内でバッファ内容を取得する（重要）
                                try:
                                    captured_output = output_buffer.getvalue()
                                    if captured_output:
                                        logger.debug(f"キャプチャした出力（先頭300文字）: {captured_output[:300]}...")
                                except Exception as buffer_err:
                                    logger.error(f"バッファ読み取りエラー: {buffer_err}")
                        except Exception as redirect_err:
                            logger.error(f"出力リダイレクトエラー: {redirect_err}", exc_info=True)
                            print(f"[PYTHON_DEBUG] 出力リダイレクトエラー: {redirect_err}", file=sys.stderr, flush=True)
                            # リダイレクトなしで処理を続行
                            text_options = clean_options(options).copy()
                            text_options['verbose'] = False
                            
                            logger.info("リダイレクトなしでのOCR処理再試行")
                            print("[PYTHON_DEBUG] リダイレクトなしでのOCR処理再試行", file=sys.stderr, flush=True)
                            text_result = image_analyzer.extract_text_from_image(image=image, **text_options)
                            logger.info("リダイレクトなしでのOCR処理完了")
                            print("[PYTHON_DEBUG] リダイレクトなしでのOCR処理完了", file=sys.stderr, flush=True)
                        
                        # OCR結果のデータ構造を検証
                        logger.info(f"OCR結果タイプ: {type(text_result).__name__}")
                        print(f"[PYTHON_DEBUG] OCR結果タイプ: {type(text_result).__name__}", file=sys.stderr, flush=True)
                        
                        if isinstance(text_result, dict):
                            logger.info(f"OCR結果構造: キー={list(text_result.keys())}")
                            print(f"[PYTHON_DEBUG] OCR結果構造: キー={list(text_result.keys())}", file=sys.stderr, flush=True)
                        
                        logger.info("テキスト抽出完了")
                        print("[PYTHON_DEBUG] テキスト抽出完了", file=sys.stderr, flush=True)
                        
                        # 結果をマージ
                        if isinstance(text_result, dict):
                            if 'text' in text_result:
                                result['text'] = text_result.get('text', '')
                            if 'textBlocks' in text_result:
                                result['textBlocks'] = text_result.get('textBlocks', [])
                            if 'ocr_status' in text_result:
                                result['ocr_status'] = text_result.get('ocr_status')
                        else:
                            logger.warning(f"テキスト抽出結果が辞書型ではありません: {type(text_result)}")
                    except Exception as text_err:
                        logger.error(f"テキスト抽出エラー: {str(text_err)}", exc_info=True)
                        result['text_error'] = str(text_err)
                
                # 色抽出
                if not options.get('skip_colors', False):
                    try:
                        logger.info("色抽出処理開始")
                        print("色抽出処理開始", file=sys.stderr, flush=True)
                        colors_result = image_analyzer.extract_colors_from_image(image, **options)
                        
                        # 型チェックを追加して適切に処理
                        if isinstance(colors_result, dict):
                            # 辞書型の場合はcolorsキーの値を取得
                            result['colors'] = colors_result.get('colors', [])
                        elif isinstance(colors_result, list):
                            # リスト型の場合はそのまま使用
                            result['colors'] = colors_result
                        else:
                            # その他の型の場合は空リストにフォールバック
                            logger.warning(f"予期しない色抽出結果の型: {type(colors_result)}")
                            result['colors'] = []
                            
                        logger.info(f"色抽出完了: {len(result['colors'])}色")
                    except Exception as color_err:
                        logger.error(f"色抽出エラー: {str(color_err)}", exc_info=True)
                        result['color_error'] = str(color_err)
                
                # 実行時間を記録
                end_time = time.time()
                result['processing_time_ms'] = int((end_time - start_time) * 1000)
                
                return result
            except Exception as e:
                logger.error(f"analyze_all内部処理エラー: {str(e)}", exc_info=True)
                return {
                    'success': False,
                    'error': f"総合分析エラー: {str(e)}",
                    'text': '',
                    'textBlocks': [],
                    'colors': []
                }
        
        # 画像をデコード
        logger.info("画像データのデコード開始")
        image, format_name = base64_to_image_data(image_data)
        logger.info(f"画像データのデコード完了: 形式={format_name}")
        
        # 総合分析を実行
        logger.info("総合分析の実行...")
        result = analyze_all(image, clean_opts)
        
        # 結果の確認
        if result.get('error'):
            logger.warning(f"analyze_all関数内でエラーが発生しましたが、部分的な結果を返します: {result['error']}")
            print(f"analyze_all関数内でエラーが発生しましたが、部分的な結果を返します: {result['error']}", file=sys.stderr, flush=True)
        
        # Windows環境向けに追加のデバッグ情報
        if os.name == 'nt':
            result_size = len(json.dumps(result))
            logger.info(f"Windows環境: analyze_all関数完了 - 結果サイズ: {result_size}バイト")
            logger.info(f"Windows環境: 結果内容サンプル: colors={len(result.get('colors', []))}個, textBlocks={len(result.get('textBlocks', []))}個")
            print(f"Windows環境: analyze_all関数完了 - 結果サイズ: {result_size}バイト", file=sys.stderr, flush=True)
            sys.stderr.flush()
        
        logger.info(f"analyze_all関数呼び出し完了、結果を送信します")
        send_response(request_id, result)
    except Exception as e:
        error_msg = f"analyze_all処理中にエラーが発生: {str(e)}"
        logger.error(error_msg, exc_info=True)
        print(error_msg, file=sys.stderr, flush=True)
        send_response(request_id, None, error=error_msg)

def handle_check_environment(request_id: str, params: Dict[str, Any]):
    """Pythonサーバー環境が正常に動作しているか確認する"""
    try:
        # モジュール依存関係のチェック
        missing_modules = []

        for module_name in ["numpy", "cv2", "PIL"]:
            try:
                importlib.import_module(module_name)
            except ImportError:
                missing_modules.append(module_name)

        # 画像解析モジュールの状態をチェック
        analyzer_status = "正常" if image_analyzer else "未初期化"

        result = {
            "status": "ok" if not missing_modules and analyzer_status == "正常" else "error",
            "python_version": sys.version,
            "missing_modules": missing_modules,
            "analyzer_status": analyzer_status,
            "timestamp": datetime.now().isoformat()
        }

        send_response(request_id, result)

    except Exception as e:
        logger.error(f"環境チェック中にエラーが発生しました: {str(e)}")
        send_response(request_id, None, f"環境チェックエラー: {str(e)}")

def handle_setup_environment(request_id: str, params: Dict[str, Any]):
    """Pythonサーバー環境をセットアップする"""
    try:
        # 必要に応じて依存関係のインストールを含むセットアップ作業
        # （実際のデプロイメントでは、このロジックはセキュリティを考慮して調整が必要）

        # 画像解析モジュールを初期化
        init_success = initialize_image_analyzer()

        result = {
            "status": "ok" if init_success else "error",
            "timestamp": datetime.now().isoformat()
        }

        send_response(request_id, result)

    except Exception as e:
        logger.error(f"環境セットアップ中にエラーが発生しました: {str(e)}")
        send_response(request_id, None, f"環境セットアップエラー: {str(e)}")

def base64_to_image_data(image_data_base64: str) -> Tuple[Any, str]:
    """Base64エンコードされた画像データをデコードする"""
    if not image_analyzer:
        raise ValueError("画像解析モジュールが初期化されていません")

    try:
        # Base64形式チェック
        if ',' in image_data_base64:
            # Data URI形式の場合（例: data:image/jpeg;base64,/9j/4AAQSkZ...）
            header, encoded = image_data_base64.split(',', 1)
            image_format = header.split(';')[0].split('/')[1] if ';' in header and '/' in header.split(';')[0] else 'jpeg'
        else:
            # 純粋なBase64文字列の場合
            encoded = image_data_base64
            image_format = 'jpeg'  # デフォルト形式

        # Base64をデコードして画像データを取得
        image_bytes = base64.b64decode(encoded)

        # image_analyzer.pyの関数を使用して画像データを変換
        image = image_analyzer.decode_image(image_bytes)

        return image, image_format

    except Exception as e:
        logger.error(f"画像データのデコード中にエラーが発生しました: {str(e)}")
        raise

def handle_extract_colors(request_id: str, params: Dict[str, Any]):
    """画像から主要な色を抽出する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data = None
        # 複数の可能なキー名をチェック
        for key in ['image_data', 'imageData', 'image']:
            if key in params and params[key]:
                image_data = params[key]
                logger.info(f"受信パラメータのキー: {list(params.keys())}")
                logger.info(f"画像データ形式: {type(image_data).__name__}")
                logger.info(f"画像データサイズ: {len(image_data) if isinstance(image_data, str) else 'N/A'}")
                logger.info(f"画像データプレビュー: {image_data[:50]}..." if isinstance(image_data, str) and len(image_data) > 50 else 'N/A')
                break

        options = params.get('options', {})

        if not image_data:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data)

        # image_analyzer.pyのextract_colors_from_image関数を呼び出す
        # オプションのimageを除外して衝突回避
        if 'image' in options:
            logger.warning("[debug] options に 'image' が含まれているため除去します")
            options.pop('image')

        colors = image_analyzer.extract_colors_from_image(image=image, **options)

        # 抽出結果のデータ型と構造を詳細に検証
        logger.info(f"色抽出結果（生データ）: {len(colors)}色")
        logger.info(f"色抽出結果データ型: {type(colors).__name__}")

        if len(colors) > 0:
            logger.info(f"最初の色データ構造: {type(colors[0]).__name__}")
            if isinstance(colors[0], dict):
                logger.info(f"最初の色データキー: {list(colors[0].keys())}")
                logger.info(f"最初の色データ値: hex={colors[0].get('hex', 'なし')}, rgb={colors[0].get('rgb', 'なし')}")

        # JavaScriptに返す際のデータ構造を修正（colors配列をcolorsプロパティの値とする）
        logger.debug(f"色抽出結果をJSに適した形式に変換: {len(colors)}色 → colors辞書プロパティ")
        result = {"colors": colors}

        send_response(request_id, result)

    except Exception as e:
        logger.error(f"色抽出中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"色抽出エラー: {str(e)}")

def handle_analyze_sections(request_id: str, params: Dict[str, Any]):
    """画像のセクションを分析する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data_base64 = params.get('image_data', '')
        options = params.get('options', {})

        if not image_data_base64:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data_base64)

        # image_analyzer.pyのanalyze_sections関数を呼び出す
        # オプションのimageを除外して衝突回避
        if 'image' in options:
            logger.warning("[debug] options に 'image' が含まれているため除去します")
            options.pop('image')

        sections = image_analyzer.analyze_image_sections(image=image, **options)

        send_response(request_id, sections)

    except Exception as e:
        logger.error(f"セクション分析中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"セクション分析エラー: {str(e)}")

def handle_analyze_layout(request_id: str, params: Dict[str, Any]):
    """画像のレイアウトパターンを分析する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data_base64 = params.get('image_data', '')
        options = params.get('options', {})

        if not image_data_base64:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data_base64)

        # image_analyzer.pyのanalyze_layout_pattern関数を呼び出す
        # オプションのimageを除外して衝突回避
        if 'image' in options:
            logger.warning("[debug] options に 'image' が含まれているため除去します")
            options.pop('image')

        layout = image_analyzer.analyze_layout_pattern(image=image, **options)

        send_response(request_id, layout)

    except Exception as e:
        logger.error(f"レイアウト分析中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"レイアウト分析エラー: {str(e)}")

def handle_detect_main_sections(request_id: str, params: Dict[str, Any]):
    """画像のメインセクションを検出する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data_base64 = params.get('image_data', '')
        options = params.get('options', {})

        if not image_data_base64:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data_base64)

        # オプションのimageを除外して衝突回避
        if 'image' in options:
            logger.warning("[debug] options に 'image' が含まれているため除去します")
            options.pop('image')

        # image_analyzer.pyのdetect_main_sections関数を呼び出す
        sections = image_analyzer.detect_main_sections(image=image, **options)

        send_response(request_id, sections)

    except Exception as e:
        logger.error(f"メインセクション検出中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"メインセクション検出エラー: {str(e)}")

def handle_detect_card_elements(request_id: str, params: Dict[str, Any]):
    """画像からカード要素を検出する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data_base64 = params.get('image_data', '')
        options = params.get('options', {})

        if not image_data_base64:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data_base64)

        # image_analyzer.pyのdetect_card_elements関数を呼び出す
        # オプションのimageを除外して衝突回避
        if 'image' in options:
            logger.warning("[debug] options に 'image' が含まれているため除去します")
            options.pop('image')

        cards = image_analyzer.detect_card_elements(image=image, **options)

        send_response(request_id, cards)

    except Exception as e:
        logger.error(f"カード要素検出中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"カード要素検出エラー: {str(e)}")

def handle_detect_elements(request_id: str, params: Dict[str, Any]):
    """画像から特徴的な要素を検出する"""
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        image_data_base64 = params.get('image_data', '')
        options = params.get('options', {})

        if not image_data_base64:
            raise ValueError("画像データが提供されていません")

        # Base64データを画像に変換
        image, _ = base64_to_image_data(image_data_base64)

        # image_analyzer.pyのdetect_feature_elements関数を呼び出す
        # オプションのimageを除外して衝突回避
        if 'image' in options:
            logger.warning("[debug] options に 'image' が含まれているため除去します")
            options.pop('image')

        elements = image_analyzer.detect_feature_elements(image=image, **options)

        send_response(request_id, elements)

    except Exception as e:
        logger.error(f"特徴的要素検出中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"特徴的要素検出エラー: {str(e)}")

def handle_compress_analysis(request_id: str, params: Dict[str, Any]):
    """
    画像解析結果を圧縮する
    """
    try:
        if not image_analyzer:
            raise ValueError("画像解析モジュールが初期化されていません")

        # パラメータを取得
        analysis_data = params.get('analysis_data', {})
        options = params.get('options', {})

        if not analysis_data:
            raise ValueError("解析データが提供されていません")

        # 圧縮処理を実行
        logger.info("!!!!! 圧縮処理の直前 !!!!!")
        logger.error("!!!!! 圧縮処理の直前 !!!!!")  # errorレベルにして確実に出力
        compressed_data = image_analyzer.compress_analysis_results(analysis_data, options)
        logger.info("!!!!! 圧縮処理の直後 !!!!!")
        logger.error("!!!!! 圧縮処理の直後 !!!!!")  # errorレベルにして確実に出力

        # デバッグ: 圧縮データの全容をログに出力
        logger.info("===== 圧縮・構造化データの全容 (compress_analysis) =====")
        logger.info(json.dumps(compressed_data, ensure_ascii=False, default=str))
        logger.info("===== 圧縮・構造化データの出力終了 =====")

        # タイムスタンプを追加
        if 'timestamp' not in compressed_data:
            compressed_data['timestamp'] = datetime.now().isoformat()

        send_response(request_id, compressed_data)

    except Exception as e:
        logger.error(f"解析結果圧縮中にエラーが発生しました: {str(e)}")
        logger.error(traceback.format_exc())
        send_response(request_id, None, f"解析結果圧縮エラー: {str(e)}")

def main():
    """メインの実行ループ"""
    logger.info("Pythonサーバーを起動しています...")

    # Windows実行環境で標準出力がElectronから呼び出されている場合、stdout封印
    if os.name == 'nt' and not sys.stdin.isatty():
        logger.info("Windows環境でElectronから呼び出されました。標準出力を抑制します。")
        sys.stdout = open(os.devnull, 'w')

    # 画像解析モジュールを初期化
    init_success = initialize_image_analyzer()
    
    if not init_success:
        logger.error("画像解析モジュールの初期化に失敗しました。終了します。")
        return
    
    # メインループ
    while True:
        try:
            # 標準入力からリクエストを受け取る
            request = read_request()
            
            # リクエストがない場合は終了
            if request is None:
                logger.info("標準入力が閉じられました。終了します。")
                break
                
            # リクエストIDの取得
            request_id = request.get('id', str(uuid.uuid4()))
            
            # コマンドの取得
            command = request.get('command')
            
            # コマンド名と引数をログに記録
            param_info = {k: v for k, v in request.items() if k not in ['id', 'command', 'image_data']}
            logger.info(f"コマンド受信: {command} (ID: {request_id}) パラメータ: {param_info}")
            
            if command == 'extract_colors':
                handle_extract_colors(request_id, request)
            elif command == 'extract_text':
                handle_extract_text(request_id, request)
            elif command == 'analyze_sections':
                handle_analyze_sections(request_id, request)
            elif command == 'analyze_layout':
                handle_analyze_layout(request_id, request)
            elif command == 'detect_main_sections':
                handle_detect_main_sections(request_id, request)
            elif command == 'detect_card_elements':
                handle_detect_card_elements(request_id, request)
            elif command == 'detect_elements':
                handle_detect_elements(request_id, request)
            elif command == 'analyze_all':
                handle_analyze_all(request_id, request)
            elif command == 'compare_images':
                handle_compare_images(request_id, request)
            elif command == 'compress_analysis':
                handle_compress_analysis(request_id, request)
            elif command == 'exit':
                handle_exit(request_id, request)
                break
            elif command == 'check_memory':
                handle_check_memory(request_id, request)
            elif command == 'check_environment':
                handle_check_environment(request_id, request)
            elif command == 'setup_environment':
                handle_setup_environment(request_id, request)
            else:
                send_response(request_id, error=f"不明なコマンド: {command}")
            
        except Exception as e:
            logger.error(f"リクエスト処理中にエラーが発生: {str(e)}")
            logger.error(traceback.format_exc())
            try:
                send_response('error', error=f"リクエスト処理中に予期しないエラーが発生: {str(e)}")
            except:
                pass

    logger.info("Pythonサーバーが終了しました。")

if __name__ == "__main__":
    main()
